/* 【程序功能】哈弗曼编码长度计算器
   【核心知识点】
      1. 字符串字符统计
      2. 手写最小堆 (Min-Heap) 实现优先队列
      3. 贪心算法 (Huffman Coding 逻辑)
*/

#include <cstdio> // 引入C语言标准输入输出库 (比iostream更快)

// 使用 long long (简写为 ll) 防止数据溢出
// 因为哈弗曼编码累加过程中的数字可能会很大，int (20亿) 可能不够用
typedef long long ll;

// --- 堆的全局变量定义 ---

ll h[100];  // 堆数组：用来存放频率数据。因为是存26个字母，100个格子足够了
int sz = 0; // 堆的大小：当前堆里存了多少个元素

// --- 辅助函数：交换两个数 ---
void mySwap(ll &a, ll &b) {
    ll temp = a;
    a = b;
    b = temp;
}

// --- 核心操作1：入堆 (Push) ---
// 作用：把一个新数字放进堆里，并保证它浮动到正确的位置，维持“最小堆”特性
void push(ll val) {
    sz++;           // 1. 堆大小加 1 (扩展一个新位置)
    h[sz] = val;    // 2. 把新元素先放到数组的最后面 (完全二叉树的末尾)
    
    // --- 开始上浮 (Shift Up) ---
    int i = sz;     // i 代表新元素当前的下标
    while (i > 1) { // 只要还没浮到堆顶 (堆顶下标是1)
        int p = i / 2; // p 是 i 的父节点下标 (Parent)
        
        // 如果儿子(i) 比 爸爸(p) 小，说明违反了最小堆规则(爸爸必须最小)
        if (h[i] < h[p]) {
            mySwap(h[i], h[p]); // 交换父子位置
            i = p;              // 儿子现在的坐标变成了刚才爸爸的坐标，继续往上查
        } else {
            break; // 如果儿子比爸爸大，说明位置正确，停止上浮
        }
    }
}

// --- 核心操作2：出堆 (Pop) ---
// 作用：删除堆顶元素(最小值)，并重新整理堆
void pop() {
    if (sz < 1) return; // 如果堆是空的，直接返回，防止报错
    
    h[1] = h[sz]; // 1. 关键步骤：把堆的“最后一名”直接提拔到“堆顶”，覆盖掉要删除的最小值
                  //    这样能保证堆的结构不出现空洞
    sz--;         // 2. 堆的大小减 1 (原来的最后一名已经在逻辑上被删掉了)
    
    // --- 开始下沉 (Shift Down) ---
    int i = 1;    // i 指向现在的堆顶 (刚才那个被强行提拔上来的最后一名)
    while (i * 2 <= sz) { // 只要 i 还有左孩子 (i*2 不越界)，就说明还没沉到底
        int child = i * 2; // 先假设我们要跟左孩子比较
        
        // 如果有右孩子 (child+1 <= sz) 且 右孩子比左孩子更小
        // 那我们要找更小的那个孩子来跟父亲 PK
        if (child + 1 <= sz && h[child + 1] < h[child]) {
            child++; // child 指针移到右孩子身上
        }
        
        // 开始 PK：如果选出来的孩子(child) 比 父亲(i) 小
        if (h[child] < h[i]) {
            mySwap(h[child], h[i]); // 父亲能力不行，被孩子换下来
            i = child;              // 父亲现在的坐标沉到了 child 的位置，继续往下查
        } else {
            break; // 如果父亲比两个孩子都小，说明位置坐稳了，停止下沉
        }
    }
}

// --- 辅助操作：获取堆顶 ---
ll top() {
    return h[1]; // 最小堆的性质：数组第 1 个位置永远是最小的
}

// --- 主函数 ---
int main() {
    // 1. 统计频率
    ll freq[26] = {0}; // 存放26个字母的出现次数。freq[0]对应'a', freq[1]对应'b'...
    char c;
    ll totalChars = 0; // 记录总共读入了多少个字符
    
    // 循环读取字符，直到遇到文件结束符(EOF)
    while ((c = getchar()) != EOF) {
        if (c >= 'a' && c <= 'z') {
            // 如果是小写字母
            freq[c - 'a']++; // 对应的计数器加 1
            totalChars++;    // 总字符数加 1
        } else if (c == '\n' && totalChars > 0) {
            // 如果读到换行符，且前面已经读到过内容了，就结束输入
            // (这是为了防止无限等待输入)
            break;
        }
    }

    // 2. 将统计好的频率放入堆中
    sz = 0; // 初始化堆大小
    int uniqueChars = 0; // 记录有多少种不同的字符 (比如 "aaabb" 有 a,b 两种)
    
    for (int i = 0; i < 26; i++) {
        if (freq[i] > 0) {    // 只处理出现过的字母
            push(freq[i]);    // 把它的频率扔进堆里
            uniqueChars++;    // 种类数 +1
        }
    }

    ll totalLength = 0; // 最终结果：压缩后的总比特长度

    // --- 特殊情况处理 ---
    if (uniqueChars == 1) {
        // 如果只有一种字符 (例如 "AAAAA")
        // 哈弗曼树无法构建(无法合并)，通常我们用 1 位来表示这个字符
        // 所以总长度 = 字符的总个数
        totalLength = totalChars;
    } else {
        // --- 3. 哈弗曼贪心算法 (核心逻辑) ---
        // 只要堆里还有多于 1 个元素，说明还没合并成一棵大树
        while (sz > 1) {
            ll a = top(); pop(); // 1. 取出当前频率最小的数 (a)
            ll b = top(); pop(); // 2. 取出当前频率第二小的数 (b)
            
            ll sum = a + b;      // 3. 把它们合并成一个新节点
            
            // 【关键点】 为什么累加 sum 就是总长度？
            // 每次合并，意味着这两个节点下的所有字符编码长度都增加了 1 位。
            // 增加的比特数 = 这两个节点的频率之和。
            totalLength += sum; 
            
            push(sum);           // 4. 把合并后的新频率放回堆里，参与下一轮竞争
        }
    }

    // 输出最终结果
    printf("%lld\n", totalLength);

    return 0;
}