# C++ 数据结构与算法（无 STL 实现）

[English](README.md) | [中文](README_zh.md)

> **“我不能创造的，我就不理解。”** — 理查德·费曼

本仓库展示了使用 **纯 C++** 对核心数据结构和算法的深入探索。所有实现均从头开始构建，**未使用标准模板库 (STL)**，以确保对内存管理、指针运算和算法效率有深刻理解。

## 🚀 项目亮点

这不仅仅是作业集合。它专注于与量化金融和高性能计算 (HPC) 相关的 **性能优化** 和 **底层机制**。

### 1. 手动内存管理与优化
* **静态内存池**：在 `05_Trees/BST_Rank_Ops.cpp` 中，我实现了一个静态内存池 (`Node pool[MAXN]`)，而不是重复使用 `new/delete`。这防止了内存碎片，并显著减少了高频操作中的分配开销。
* **缓存友好访问**：在 `03_Matrix/SparseMatrix.cpp` 中，我通过先 **转置矩阵** 来优化稀疏矩阵乘法。这将列访问转换为行访问，最大化了 **CPU 缓存命中率** 和线性内存扫描。

### 2. 自定义数据结构
* **手写堆**：手动实现了二叉小顶堆 (`06_Heap`) 以支持 **霍夫曼编码** 和 **Prim 算法** 的优先队列，替代了 `std::priority_queue`。
* **链式前向星**：在 `07_Graph` 中使用基于数组的邻接表（链式前向星）进行图表示，这比标准的基于向量的邻接表 (`std::vector<std::vector<int>>`) 更节省内存。

### 3. 算法实现
* **排序**：从头实现了 **快速排序** 和 **归并排序**（用于链表），以处理自定义比较器和稳定性要求。
* **图算法**：实现了用于 MST 的 **Kruskal 算法**（使用并查集）和 **Prim 算法**。

---

## 📂 仓库目录

| 模块 | 描述与关键文件 |
| :--- | :--- |
| **00_Basics** | **递归与位运算**：用于子集异或和及组合的 DFS。 |
| **01_LinearList** | **指针与内存**：`SeqList`、`SinglyLinkedList` 和链表合并。 |
| **02_StackQueue** | **缓冲区**：循环队列（环形缓冲区）和表达式求值（栈）。 |
| **03_Matrix** | **稀疏矩阵**：三元组表示、转置优化和乘法。 |
| **04_HashTable** | **哈希表**：开放寻址法（线性探测）与链地址法的实现。 |
| **05_Trees** | **BST 与重构**：前序/中序重构、使用 **内存池** 的排名操作。 |
| **06_Heap** | **优先队列**：手动小顶堆实现与霍夫曼编码。 |
| **07_Graph** | **图论**：使用自定义数据结构的 BFS/DFS、MST (Prim/Kruskal)。 |
| **08_Sorting** | **排序算法**：基于模板的排序与链表归并排序。 |

---

## 🛠️ 构建与运行

由于未使用外部库，您可以使用 `g++` 编译任何文件。

**示例：运行稀疏矩阵模块**
```bash
cd 03_Matrix
g++ SparseMatrix.cpp -o matrix_test -O2
./matrix_test
```
